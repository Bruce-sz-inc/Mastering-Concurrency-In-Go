#### 理解goroutines和coroutines

到目前为止，你可能会想，goroutines我想跟coroutines差不多，答案是yes也是no。

coroutines是一种协作任务的控制机制，但从最简化的定义看，coroutines不是并发。虽然coroutines和goroutines被类似的使用着，Go专注与并发不限于状态控制和控制权转移。在目前我们看到的例子中，我们可以说看到的是哑巴一样的goroutines，在两个goroutines之间并没有真正的通信，虽然他们在同一时间对同一片地址区域进行操作。如果你观察其他语言的coroutines，你会发现并发并不是必须的或者异步的，而是按照流程来的。它们出让控制权给main()和彼此，但两个coroutines也许并不需要进行交流，依赖于一个中心化的、直白的数据共享系统。

#### 原生的coroutines

coroutines 第一次是Melvin Conway为COBOL所设计，在这片论文Design of a Separable Transition-Diagram Compiler，他建议coroutines的目的是将程序拆分为多个子任务，并让它们独立运行，只共享一小部分数据。

goroutines有些地方违反了Conway设计的coroutines的基本原则，比如，Conway建议执行顺序应该是单向的，换句话说，A->B->C->D,可以代表一个coroutines程序的通信过程，我们知道goroutines可以并行的运行，也可以按照任意的顺序执行，在这点上，我们的goroutines没有共享任何信息，它们只是简单的用同样的模式运行。